---
layout: default
title: Home
---

{{"### Research questions

Here are the main questions we asked ourselves when we started working on this project:

1. **Röstigraben, Polentagraben, countryside-cities split:**
Our main point of focus is to observe political division in Switzerland, and its correlation with different cultural aspects such as language and urban status. Is there a recurrence in the splits during votations? Do they differ depending on the topics?

2. **Outliers:**
We are interested to find out about entities that we may call «chronical winners» and «chronical losers», in other words cantons/regions/towns that are often on parity with votation results and those that often vote the opposite. Is it a phenomenon limited to few entities or a common one?

### Dataset

The main dataset being used is the results of all the popular votations from 1981 to May 2017 in Switzerland published by Swiss Federal Statistical Office. The dataset is available [here](https://www.bfs.admin.ch/bfs/fr/home/statistiques/politique/votations.assetdetail.3362356.html).

The data are available as HTML tables that can be parsed using the _requests_ library and the convenient pandas function _read\_html_. The only small issue here is that the entire table is not available at once, it is then necessary to scrap multiple small table and then merge them, which is what we do in the notebook named `bfs_scrap.ipynb`.

Note that votes are anonymized. Thus, it is not possible to get reliable data on an individual basis (fortunately for the voters). However, it is possible to enrich our dataset, as we need, with demographical data for each town also published by the Swiss Federal Statistical Office. These data are always available either as Excel spreadsheets or HTML tables. In both cases we managed to easily parse them and integrate them.

### Objectives
Our main objective in this project is to implement machine learning techniques, namely K-Means and DBSCAN to generate clusters of similarly voting communities using the votation data in order to determine the existence of political divides in Switzerland. With the data we have, it is thus possible to observe not only the divides, but their evolution over time or their status depending on the theme of the vote. Our reasoning behind this idea is that we feel it is extremely arbitrary to sort votation topics by how liberal or conservative they are, and thus we cannot just aggregate votation scores together to get «liberal scores» for each region.

To visualize our data, we use the `Folium` plugin for Python to generate maps using our results and geographical data taken from [OpenStreetMap.org](www.openstreetmap.org) that we have slightly modified for various reasons, including community mergers, wrong orthograph in names of locations and various inconsistencies with the boundaries of certain communities.


### Introduction structure of the story
In this data story we will use two methods: simple aggregation of data (for example adding the voting results of all years) and clustering using K-Means and DBSCAN. We will try to extract as much relevant information as possible from that. Our data is given at the community level (there are about 3'000 communities in Switzerland). What we will look at is the following, using several methods when we see fit:

- Repartition of languages in the country
- Raw results
- Results by theme (8 different themes)
- Comparison with party recommendations

A FAIRE QUAND LE RESTE EST FAIT"  | markdownify }}


{% for post in paginator.posts %}
<div class="posts">
  <h1>
    <a href="{{ site.github.url }}{{ post.url }}">{{ post.title }}</a>
  </h1>
  {% if post.image %}
  <div class="thumbnail-container">
    <a href="{{ site.github.url }}{{ post.url }}"><img src="{{ site.github.url }}/assets/img/{{ post.image }}"></a>
  </div>
  {% endif %}
  <p>
    {{ post.content | strip_html | truncate: 350 }} <a href="{{ site.github.url }}{{ post.url }}">Read more</a>
    </p>
</div>
{% endfor %}

<!-- Pagination links -->
{% if paginator.total_pages > 1 %}
<div class="pagination">
  {% if paginator.next_page %}
    <a class="pagination-button pagination-active" href="{{ site.github.url }}{{ paginator.next_page_path }}" class="next">Older</a>
  {% else %}
    <span class="pagination-button">Older</span>
  {% endif %}
  {% if paginator.previous_page %}
    <a class="pagination-button pagination-active" href="{{ site.baseurl }}{{ paginator.previous_page_path }}">Newer</a>
  {% else %}
    <span class="pagination-button">Newer</span>
  {% endif %}
</div>
{% endif %}
